use std::fs::File;
use std::io::{Seek, SeekFrom};
use std::path::{Path, PathBuf};
use derive_builder::Builder;
use tempfile::NamedTempFile;
use crate::{files};
use crate::files::{create_temp_file, replace_file, safe_get_parent};
use crate::stream_encryption::{decrypt_stream, encrypt_stream, EncryptedType, HeaderChunk};
use crate::errors::{CryptorEngine as CryptorEngineError, CryptorEngine, Error};

/// Since an Engine can only encrypt one file, an EngineGenerator let's you create
/// as many engine as you want and reuse the same bincode config and the same HeaderChunk.
/// The header chunk is mainly use to specify the salt to use and the [encryption type](EncryptedType).
///
/// You should create a new engine (with engine_from_path) every time you encrypt/decrypt a file.
/// If you don't supply a HeaderChunk, a new one will automatically be created when encrypting a file.
///
#[derive(Builder)]
pub struct EngineGenerator {
    #[builder(default)]
    config: Option<bincode::config::Configuration>,

    #[builder(default)]
    header_chunk: Option<HeaderChunk>,
}

impl EngineGenerator {

    /// This method let's us generate a cryptor engine using the settings we supplied in the EngineGenerator
    /// as well as the supplied path (path to a file or a directory).
    ///
    /// This method will generate the new engine with the necessary parameters. Whether they are loaded
    /// from the input_file_path or from the EngineGenerator settings depends on the engine goal.
    ///
    /// # Errors
    ///     * can fail if the file/directory cannot be opened
    ///     * can fail if a temp file cant be created
    ///     * can fail when transfering configurations (should not happen)
    ///
    /// # Example
    ///
    /// ```no_run
    /// use rustware::cryptor_engine;
    /// use std::path::Path;
    ///
    ///  let target = Path::new("."); // target current directory
    ///  let engine_builder = cryptor_engine::EngineGeneratorBuilder::default()
    ///         .build().expect("could not generate cryptor engine generator");
    ///  let engine = engine_builder.engine_from_path(target);
    /// ```
    pub fn engine_from_path(&self, input_file_path: &Path) -> Result<Engine, Error> {
        let mut engine =match input_file_path.is_file() {
            true => {
                Engine::try_from_file(input_file_path)?
            }
            false => {
                Engine::try_with_archive(input_file_path)?
            }
        };

        if self.config.is_some() {
            engine.config =
                self.config.clone()
                    .ok_or(CryptorEngineError::UnexpectedEngineGeneratorFailure)?;
        }

        if self.header_chunk.is_some() {
            engine.header_chunk = self.header_chunk.clone()
                    .ok_or(CryptorEngineError::UnexpectedEngineGeneratorFailure)?;
        }

        Ok(engine)
    }
}

/// This struct holds all the necessary information in order to encrypt/decrypt a file.
/// It is generated by the EngineGenerator struct/builder. See EngineGenerator for more information.
pub struct Engine {
    config: bincode::config::Configuration,
    header_chunk: HeaderChunk,
    temp_file: NamedTempFile,
    input_file: File,
    input_file_path: PathBuf,
}

impl Engine {

    /// This method tries to create a new engine based off a file path.
    /// If the file exists, is readable and a temporary file can be created
    /// (either next to the file or in os temp dir), this method should succeed.
    ///
    /// We try to open the input_file_path with read permissions only
    /// and we disable truncating.
    /// 
    /// This method also automatically decides whether we're encrypting
    /// a file (EncryptionType::Raw) or a directory (EncryptionType::Archive)
    ///
    /// # Errors
    ///   * if input_file_path can't be open
    ///   * if a temp file cant be created (current dir or temp folder)
    ///   * if rust fails to fetch input file metadata
    ///
    /// # Examples
    /// refer to the documentation of EngineGenerator::engine_from_path
    fn try_from_file(input_file_path: &Path) -> Result<Self, Error> {
        let tmp_file = create_temp_file(
            safe_get_parent(&input_file_path).as_path()
        )?;

        let length = input_file_path.metadata()
            .map_err(|_| CryptorEngineError::FetchFileMetadataFailed)?
            .len();
        let h = HeaderChunk::with_file_length(length);

        Ok(
            Self {
                header_chunk: h,
                config: bincode::config::standard(),
                temp_file: tmp_file,
                input_file: File::options()
                    .read(true)
                    .create(false)
                    .open(input_file_path)
                    .map_err(|e| CryptorEngineError::FileIOError(e))?,
                input_file_path: input_file_path.to_path_buf()
            }
        )
    }
    
    /// This method tries to archive input_directory_path (using tar) and temporary files.
    /// If the directory is archived successfully, we erase the directory and rename our archive
    /// to the directory name. We then create a tempfile (for encryption) and we initialize
    /// various parameters (`HeaderChunk`, `bincode` config, temp files) and we open the input file.
    /// 
    /// # Errors
    ///   * if we cant create temp files
    ///   * if we cant open input file
    ///   * if we cant delete the directory after archiving it
    ///   * if we cant get the necessary input file metadata
    /// 
    /// # Examples
    /// refer to `EngineGenerator::engine_from_path`
    fn try_with_archive(input_directory_path: &Path) -> Result<Self, Error> {
        let input_file = files::archive(input_directory_path)?;
        let tmp_file = create_temp_file(
            safe_get_parent(input_directory_path).as_path()
        )?;
        let input_file_length = input_file.as_file()
            .metadata()
            .map_err(|_| CryptorEngineError::FetchFileMetadataFailed)?
            .len();

        Ok (
            Self {
                config: bincode::config::Configuration::default(),
                header_chunk: HeaderChunk::with_file_length(input_file_length),
                temp_file: tmp_file,
                input_file_path: input_directory_path.to_path_buf(),
                input_file: input_file.into_file(),
            }
        )
    }
    
    /// This should ONLY be used if the original path was a directory - meaning
    /// `try_with_archive` needs to be called by the engine (which happens if the path
    /// is a directory). This will set the HeaderChunk EncryptedType to `Archive` and 
    /// encrypt the archive that was generated with the contents of the directory.
    /// 
    /// # Errors
    ///   * if we can't write our temp file
    ///   * if we can't encode file chunks
    ///   * if we can't encrypt the data properly
    ///   * if we can't generate a nonce for our chunk
    ///   * if we can't rename/move tempfiles
    /// 
    /// # Example
    /// 
    /// refer to projects/file_encryptor/src/main.rs
    /// 
    pub fn encrypt_archive(&mut self, password: &str) -> Result<(), Error> {
        self.encrypt(password, EncryptedType::Archive)
    }
    
    /// This method encrypts a file (using `EncryptedType::Raw`).
    /// 
    /// # Errors
    ///   * if we can't create a tempfile
    ///   * if we can't encode a file chunk
    ///   * if we can't rename our tempfile(s)
    /// 
    ///  # Examples
    /// refer to projects/file_encryptor/src/main.rs
    pub fn encrypt_file(&mut self, password: &str) -> Result<(), Error> {
        self.encrypt(password, EncryptedType::Raw)
    }
    
    /// Generic (private) version of encrypt_file/encrypt_archive to reduce code
    /// duplication. Will make sure our reader/writer are at the start of their respective files
    /// set the `EncryptionType` of our `HeaderChunk` and encrypt the whole thing.
    /// 
    /// This also handles replacing the input file with the temporary one we created.
    /// 
    /// # Errors
    ///   * if we can't seek the start of our two files properly
    ///   * if we can't encode chunks
    ///   * if we can't encrypt properly
    ///   * if we can't move our temp file
    ///   * if we can't override input with temp file
    /// 
    /// # Examples
    /// refer to projects/file_encryptor/src/main.rs
    fn encrypt(&mut self, password: &str, t: EncryptedType) -> Result<(), Error> {
        self.header_chunk.set_filetype(t);

        // make sure buffers are at the start of the files
        self.input_file.seek(SeekFrom::Start(0))
            .map_err(|_| CryptorEngine::FileSeekFailed)?;
        self.temp_file.seek(SeekFrom::Start(0))
            .map_err(|_| CryptorEngine::FileSeekFailed)?;

        encrypt_stream(
            &mut self.input_file,
            &mut self.temp_file,
            password,
            &self.header_chunk,
            &self.config
        )?;
        
        replace_file(self.temp_file.path(), self.input_file_path.as_path())?;
        Ok(())
    }
    
    /// This method decrypts a file/archive. It makes sure that are input file and temp
    /// file are at the start and decode and decrypts the data chunk by chunk.
    /// It also uses the decoded/decrypted `HeaderChunk` to see if we're decrypting an archive.
    /// If we are, then we unpack said archive (uses the same name as the input file). 
    /// 
    /// # Errors
    ///   * if we can't decode chunks
    ///   * if we can't decrypt a chunk
    ///   * if we can't manipulate files properly
    /// 
    /// # Examples
    /// refer to projects/file_encryptor/main.rs
    pub fn decrypt(&mut self, password: &str) -> Result<(), Error> {
        // make sure buffers are at the start of the files
        self.input_file.seek(SeekFrom::Start(0))
            .map_err(|_| CryptorEngine::FileSeekFailed)?;
        self.temp_file.seek(SeekFrom::Start(0))
            .map_err(|_| CryptorEngine::FileSeekFailed)?;

        let header = decrypt_stream(
            &mut self.input_file,
            self.temp_file.as_file_mut(),
            password,
            &self.config
        )?;

        replace_file(self.temp_file.path(), self.input_file_path.as_path())?;

        // post decryption jobs
        match header.get_filetype() {
            EncryptedType::Archive => {
                files::extract_archive(self.input_file_path.as_path())?;
            }
            _ => {/* nothing to do here */}
        }
        
        Ok(())
    }
}
